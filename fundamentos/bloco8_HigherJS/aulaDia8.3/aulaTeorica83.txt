INTRODUÃ‡ÃƒO
======================================

O QUE VAMOS APRENDER?
Sobre as Higher Order Functions:   >>>>>>> Array.filter e o Array.reduce. <<<<<<<

O filter e o reduce sÃ£o algumas das mais poderosas funÃ§Ãµes para MANIPULAÃ‡ÃƒO E CRIAÃ‡ÃƒO DE ARRAYS. Enquanto o filter filtra o array de acordo com alguma condiÃ§Ã£o e retorna apenas os valores que satisfizerem a essa condiÃ§Ã£o, o reduce consegue reduzir o array a um valor Ãºnico.
======================================

SKILLS ESPERADAS
        - Utilizar a funÃ§Ã£o Array.filter para filtrar um array;

        - Utilizar a funÃ§Ã£o Array.reduce para manipular arrays e construir resultados diversos;

        - Aprender a usar de forma conjunta as Higher Order Functions.
======================================

IMPORTÃ‚NCIA

Imagine que vocÃª possua um array de nÃºmeros e strings e precise somente dos nÃºmeros. Como vocÃª resolveria esse problema? ğŸ¤”

VocÃª pode ter pensado em vÃ¡rias soluÃ§Ãµes, mas nessa situaÃ§Ã£o vocÃª pode utilizar o >>> filter <<<, que, como o prÃ³prio nome diz, filtra os dados de um array. Dessa maneira, vocÃª consegue filtrar somente os nÃºmeros do array, usando apenas uma linha de cÃ³digo.

E se vocÃª precisasse somar todos os nÃºmeros desse novo array, como vocÃª faria?

Para realizar a soma de todos os nÃºmeros do array, vocÃª pode utilizar o >>> reduce <<<, que vai passar por cada nÃºmero do seu array e reduzir esse array a um valor Ãºnico.



========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================


Array.filter

O filter Ã© uma funÃ§Ã£o responsÃ¡vel por realizar algum tipo de filtro no array, de acordo com uma condiÃ§Ã£o.

Imagine que vocÃª tenha ficado responsÃ¡vel por um sistema de cadastro de clientes de uma loja de roupas e precise apenas dos nomes. Ao salvar o cadastro, o nome e o nÃºmero do telefone foram salvos dentro de um mesmo array.

O cÃ³digo abaixo mostra como ficou o resultado do array:


                  const dados = ['Luca', 91234567, 'Ana', 92345678, 'Marlete', 93456789];


Ã‰ nessa situaÃ§Ã£o que o filter entra em aÃ§Ã£o! A sintaxe dele Ã© a seguinte (mesma das outras HOFs):

                                array.filter(() => {});

O filter faz uma iteraÃ§Ã£o no array e recebe como parÃ¢metro uma callback.

                                array.filter((item) => {});

Dentro do escopo da funÃ§Ã£o Ã© onde inserimos a condiÃ§Ã£o a ser filtrada.


>>>>> Para refletir ğŸ’­: VocÃª precisa filtrar apenas o nome das pessoas do seu array dados. Ele possui dois tipos de informaÃ§Ãµes: o nome, que Ã© do tipo string, e o nÃºmero de telefone, que Ã© do tipo number. Pensando nisso, como vocÃª faria para pegar apenas os elementos do tipo string, que sÃ£o referentes ao nome das pessoas? ğŸ¤” <<<<<<


Se vocÃª pensou no filter, acertou! VocÃª pode realizar a filtragem do array dados e na condiÃ§Ã£o, verificar pelos elementos do tipo string.


                          const dados = ['Luca', 91234567, 'Ana', 92345678, 'Marlete', 93456789];

                          dados.filter((item) => {
                            // retorne apenas os elementos que sÃ£o do tipo string
                            return typeof item === 'string';
                          });
                          // ['Luca', 'Ana', 'Marlete']

VocÃª pode fazer esse cÃ³digo em apenas uma linha, omitindo a palavra return e retornando o valor logo apÃ³s a arrow =>:

                          const dados = ['Luca', 91234567, 'Ana', 92345678, 'Marlete', 93456789];

                          dados.filter((item) => typeof item === 'string');
                          // ['Luca', 'Ana', 'Marlete']


Agora vamos supor que vocÃª queira apenas os valores que nÃ£o sÃ£o strings do array dados. Como faria isso? Basta alterar a condiÃ§Ã£o do nosso filter!

                          dados.filter((item) =>  typeof item !== 'string');    // nÃ£o seja string

A condiÃ§Ã£o de dentro do filter Ã© para retornar sempre que o elemento for diferente de string.

-----------
Outro exemplo:
Imagine agora que vocÃª possua um array chamado listaNumeros com os valores 10, 20, 30, 40.

                          const listaNumeros = [10, 20, 30, 40];

VocÃª precisa somente dos nÃºmeros maiores que 20 do array listaNumeros. Como isso pode ser feito? Se vocÃª pensou em utilizar o mÃ©todo filter, acertou de novo! O array pode ser filtrado com a condiÃ§Ã£o de o nÃºmero ser maior que 20. 


                          const listaNumeros = [10, 20, 30, 40];

        // Armazena o resultado em uma nova variÃ¡vel maiorVinte
                          let maiorVinte = listaNumeros.filter((item) => {
        // retorne apenas os elementos que sÃ£o maiores do que vinte
                            return item > 20;
                          });

                          console.log(maiorVinte);

----------------------
(vÃ­deo - filter com array de objetos - Noel) - (algummmas infos aqui, outras no exScript.js)

ENTENDENDO O .filter() - exScript.js
Seleciona elementos de acordo com uma condiÃ§Ã£o. Ã‰ chamado a partir do array (array.filter()). Assim como nas demais HOFs, sÃ³ o primeiro parÃ¢metro Ã© obrigatÃ³rio, que Ã© o que vai passar por todos os elementos do array. Os outros dois sÃ£o o index e o prÃ³prio array original, mas sÃ³ sÃ£o usados em alguns casos, nÃ£o sÃ£o necessÃ¡rios, em geral.
Funciona como o 'for' por tb iterar todos os elementos. 

O .filter() SEMPRE retorna um array, mesmo que seja um sÃ³ elemento filtrado ou um array vazio.


========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================


Array.reduce

Imagine que vocÃª tenha ficado responsÃ¡vel por criar uma pÃ¡gina de carrinho de compras e para isso Ã© necessÃ¡rio realizar a soma de todos os itens do carrinho para retornar o valor final da compra.

O preÃ§o dos itens do carrinho estÃ£o dentro de um array e, para resolver esse problema, vocÃª pode utilizar o reduce, que Ã© responsÃ¡vel por passar por cada um dos valores, >>>>>>>>>>> reduzindo o array a um Ãºnico valor, que nesse caso Ã© o valor total da compra. <<<<<<<<<<<<<

Mas como o reduce funciona? ğŸ¤”

Diferente das outras HOFs, o reduce recebe dois parÃ¢metros: o primeiro Ã© uma callback, e o segundo parÃ¢metro Ã© um valor inicial (que Ã© opcional).

                              array.reduce(callback, valorInicial);

O valorInicial Ã© o valor da primeira iteraÃ§Ã£o e, em geral, ao realizar somas, esse valor Ã© 0.

JÃ¡ a callback Ã© a funÃ§Ã£o que vai passar por cada um dos itens do array, e ela pode receber atÃ© 4 parÃ¢metros, sendo eles:

     - Acumulador: que Ã© o valor que vai ser acumulado a cada iteraÃ§Ã£o;
     - Valor atual: que Ã© o valor atual do item, a ser adicionado no acumulador;
     - Index atual: que Ã© o index do item que estÃ¡ sendo iterado naquele momento;
     - Array: que Ã© o array original.

            array.reduce((acumulador, valorAtual, indexAtual, array) => { "cÃ³digo" }, valorInicial);
                                  array.reduce(() => {}, inÃ­cio);

>>>> Dos 4 parÃ¢metros que a callback pode receber, apenas dois sÃ£o obrigatÃ³rios: o ACUMULADOR e o VALOR ATUAL. <<<

==========================================================================================================
OU SEJA, no reduce Ã© obriigatÃ³rio ter a callback e na callback Ã© obrigatÃ³rio ter acumulador e valor atual.
==========================================================================================================

Os parÃ¢metros acumulador e valor atual em geral sÃ£o escritos em inglÃªs e abreviados. Sendo assim:

          o acumulador Ã© chamado de acc (accumulator);
          o valor atual Ã© chamado de curr (current value).

Temos entÃ£o que acc, abreviatura de accumulator, ou acumulador, deve obrigatoriamente ser o primeiro parÃ¢metro da callback, e o curr, abreviatura de currentValue, ou valor atual, tambÃ©m obrigatÃ³rio, deve ser o segundo parÃ¢metro da callback. Sendo assim, para trabalhar com a funÃ§Ã£o reduce vocÃª deve ter algo parecido com o cÃ³digo abaixo:


                                  array.reduce((acc, curr) => {
                                    // escopo de execuÃ§Ã£o da funÃ§Ã£o
                                  }, valorInicial);


A funÃ§Ã£o do acumulador (acc) Ã© guardar o retorno da callback a cada iteraÃ§Ã£o, e a funÃ§Ã£o do curr Ã© acessar cada um dos valores do array.



==========================================================================================================
(AULA AO VIVO COM O THALLES - VÃDEO - NOTAS)
A funÃ§Ã£o '.reduce()' reduz o array a um Ãºnico valor (pode ser uma string, um nÃºmero, um array, um objeto).

EXEMPLO NA VIDA REAL:
5 amigos vÃ£o pagar uma conta de 50 reais num bar, sendo que cada um pediu um drink de 10 reais. Ou seja, 10 reais de cada. Esse, em reduce, seria o valor do acumulador === 10.

- A primeira pessoa tem 10 reais e passa para a segunda, que agora tem os 10 reais passados e mais os seus prÃ³prios 10 reais, o que faz 20. Esse Ã© o novo acumulador === 20, ou seja, o valor acumulado naquele dado momento.
- Essa segunda pessoa passa os 20 reais para a prÃ³xima, sendo que Ã© 10 + 10, e agora essa nova pessoa vai ter 30, incluindo seus prÃ³prios 10 reais. Sendo assim, o novo acumulador Ã© 30.
- Isso vai acontecer atÃ© chegarmos Ã  Ãºltima pessoa, que vai acrescentar seus prÃ³prios 10 reais e atingir o valor de 50 reais, que Ã© o total da conta e o acumulador final.


.reduce(callbackfn, valor inicial);   // valor inicial Ã© opcional e, se estabelecido, vai ser o 1Âº valor do accumulator
        ==========
            â¬
A callbackfn Ã© obrigatÃ³ria e recebe como parÃ¢metros obrigatÃ³rios (accumulator, currentValue).
                                                                 ===========================

(accumulator, currentValue) => {}      // pode receber index e o array tb, opcionalmente


Se no fim, o array de retorno for vazio, ele vai possuir o valor inicial como elemento. Embora opcional, Ã© importante analisar quando ele Ã© necessÃ¡rio para que a funÃ§Ã£o e o accumulator possam funcionar de forma correta, de acordo com o que se quer executar. Ele ajuda com a lÃ³gica, sem ele podemos chegar em 'undefined', etc.

(PRÃTICA COM O THALLES - VSC)


==========================================================================================================



--------------------------
O cÃ³digo abaixo possui um array simulando o valor dos itens no carrinho de compras e a funÃ§Ã£o do reduce para mostrar o que cada um dos parÃ¢metros retorna. Execute o cÃ³digo abaixo no console do seu navegador e veja o que ele retorna:


                                  const valorItens = [1, 32, 44, 2, 3];

                                  valorItens.reduce((acc, curr) => {
                                    console.log(`acumulador - acc:`, acc);
                                    console.log(`valorAtual - curr:`, curr);
                                  }, 0);

Veja que, na primeira iteraÃ§Ã£o, o valor do acc Ã© 0, e depois se torna undefined.

Isso ocorre porque a funÃ§Ã£o do acumulador (acc) Ã© guardar o retorno da callback a cada iteraÃ§Ã£o, tendo como ponto de partida o valorInicial, que definimos como 0. Como a callback nÃ£o estÃ¡ retornando nada, o valor se torna undefined, porque ele nÃ£o acumulou nenhum resultado.
--------------------------

Para realizar a soma dos produtos, precisamos retornar esse cÃ¡lculo dentro da callback.

                                  valorItens.reduce((acc, curr) => {
                                    console.log(`acc:`, acc);
                                    console.log(`curr:`, curr);
                                    console.log('a soma atual Ã©', acc + curr);

                                    return acc + curr;
                                  }, 0);

Veja que, a cada iteraÃ§Ã£o, o acc e o curr sÃ£o somados, e o acc Ã© o valor acumulado da soma na iteraÃ§Ã£o anterior.

Ao final de toda a iteraÃ§Ã£o Ã© retornado o valor da soma de todos os itens do array e, nesse caso, vocÃª jÃ¡ sabe o valor total da compra.

Abaixo vocÃª pode conferir o cÃ³digo comentado com o passo a passo do que acontece:

                                  -----------------------

                                  const valorItens = [1, 32, 44, 2, 3];

                                  valorItens.reduce((acc, curr) => {
                                    console.log(`valor atual Ã© ${curr}`);

                              >>>> // Antes da primeira iteraÃ§Ã£o o valor de inÃ­cio do `acc` Ã© o valor no index 0 do array, e o valor de inÃ­cio de `curr` Ã© o valor no index 1 do array. <<<<
                                    // IteraÃ§Ã£o 1: valor do acc Ã© 1 e o de curr Ã© 32;
                                    // ApÃ³s a primeira iteraÃ§Ã£o, o valor de `acc` muda e passa a acumular agora o resultado do retorno da callback (acc + curr).
                                    // IteraÃ§Ã£o 2: valor do acc Ã© 33 e o de curr Ã© 44;
                                    // Acontece entÃ£o uma segunda iteraÃ§Ã£o, e `curr` agora assume o valor do index na sequÃªncia do array, no caso o valor do segundo index e `acc` segue armazenando os retornos.
                                    // IteraÃ§Ã£o 3: valor do acc Ã© 77 e o de curr Ã© 2;
                                    // IteraÃ§Ã£o 4: valor do acc Ã© 79 e o de curr Ã© 3;
                                    // Valor final de `acc` Ã© 82 e `curr` para no 3.

                                    return acc + curr; 
                                    
                                    // Ao fim das iteraÃ§Ãµes podemos ver que o `acc` armazenou o resultado total do retorno da funÃ§Ã£o.
                                  });


                                    console.log(`valor atual Ã© ${curr}`);
                                    // Antes da primeira iteraÃ§Ã£o o valor de inÃ­cio do `acc` Ã© o valor no index 0 do array, e o valor de inÃ­cio de `curr` Ã© o valor no index 1 do array.
                                    // IteraÃ§Ã£o 1: valor do acc Ã© 1 e o de curr Ã© 32;
                                    // ApÃ³s a primeira iteraÃ§Ã£o, o valor de `acc` muda e passa a acumular agora o resultado do retorno da callback (acc + curr).
                                    // IteraÃ§Ã£o 2: valor do acc Ã© 33 e o de curr Ã© 44;
                                    // Acontece entÃ£o uma segunda iteraÃ§Ã£o, e `curr` agora assume o valor do index na sequÃªncia do array, no caso o valor do segundo index e `acc` segue armazenando os retornos.
                                    // IteraÃ§Ã£o 3: valor do acc Ã© 77 e o de curr Ã© 2;
                                    // IteraÃ§Ã£o 4: valor do acc Ã© 79 e o de curr Ã© 3;
                                    // Valor final de `acc` Ã© 82 e `curr` para no 3.

                                    return acc + curr; // Ao fim das iteraÃ§Ãµes podemos ver que o `acc` armazenou o resultado total do retorno da funÃ§Ã£o.
                                  });

                                  ----------------------------------
Ao observar o cÃ³digo acima, identificamos tambÃ©m o papel do curr, que sempre armazena o valor do elemento atual, ou seja, o elemento do array que estÃ¡ sendo iterado no momento.


===============================================================

Passando um valor para o acc:
Imagine que novamente vocÃª queira somar todos os valores de um array. Mas agora teremos um valor inicial jÃ¡ estipulado para o acc.

                                  Com o antigo 'for':

                                  const numbers = [1, 32, 44, 2, 3];
                                  let sumNumbers = 30;

                                  // A variÃ¡vel `sumNumbers` tem um valor inicial de 30 e vai acumulando, a cada iteraÃ§Ã£o do for, o resultado da operaÃ§Ã£o feita em seu escopo!

                                  for (let index = 0; index < numbers.length; index += 1) {
                                    sumNumbers += numbers[index];
                                  }

                                  console.log(sumNumbers); 
                                  // 112


                                  -----------------------
                                  Com o 'reduce':

                                  const numbers = [1, 32, 44, 2, 3];

                                  const totalSum = numbers.reduce((acc, curr) => {
                                    console.log(`valor do acc Ã© ${acc} e o de curr Ã© ${curr}`);

                                    // IteraÃ§Ã£o 1: valor do acc Ã© 30 e o de curr Ã© 1
                                    // IteraÃ§Ã£o 2:valor do acc Ã© 31 e o de curr Ã© 32
                                    // IteraÃ§Ã£o 3: valor do acc Ã© 63 e o de curr Ã© 44
                                    // IteraÃ§Ã£o 4: valor do acc Ã© 107 e o de curr Ã© 2
                                    // IteraÃ§Ã£o 5: valor do acc Ã© 109 e o de curr Ã© 3
                                    // Valor final de `acc`Ã© 112 e `curr` para no 3


                                    return acc + curr;
                                  }, 30); 
                                  // O `valorInicial` Ã© 30, ou seja, `acc` antes de executar a primeira iteraÃ§Ã£o jÃ¡ estÃ¡ armazenando esse valor.

                                  console.log(`valor final do acc Ã© ${totalSum}`);
                                  // por fim, esse `console.log` imprime o retorno da nossa funÃ§Ã£o, que Ã© o valor final de `acc` apÃ³s cada uma das 5 iteraÃ§Ãµes, tendo iniciado com valor 30.


Pode parecer estranho definir um valor fixo para o acumulador, mas isso acontece porque estamos trabalhando com nÃºmeros. O reduce Ã© uma ferramenta poderosa e, em um cÃ³digo mais complexo, ele poderia receber um valor dinÃ¢mico, atravÃ©s de uma variÃ¡vel, ou atÃ© mesmo qualquer valor que nÃ£o seja um nÃºmero. Vale lembrar tambÃ©m que vocÃª aprendeu a usar o reduce com seus dois primeiros parÃ¢metros, mas, embora pouco utilizados, existem mais dois parÃ¢metros opcionais: index e array.


-----------------------------------------------------------------------
Veja tambÃ©m que, ao invÃ©s de passar a lÃ³gica direto dentro da callback do reduce, vocÃª pode criar uma funÃ§Ã£o externa e chamÃ¡-la como sendo o parÃ¢metro callback:

                              const numbers = [1, 32, 44, 2, 3];

                              const sumNumbers =  (acc, curr) => acc + curr;    // callback

                              const totalSum = numbers.reduce(sumNumbers, 30);

                              console.log(totalSum); //112
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------

OUTROS EXEMPLOS DE USO DO REDUCE:

>>>>> Hora de olhar outro exemplo para fixar e mostrar outras formas de se usar o reduce. Neste exemplo, serÃ£o comparados valores para buscar o maior valor em um array.
(NO VSC: maiorValor.js)

Pronto! VocÃª encontrou o maior nÃºmero do array utilizando reduce ğŸ¥³

Geralmente, para encontrar o maior valor de um array utilizando o reduce, nÃ£o utilizamos um valor inicial. Dessa forma, apenas valores presentes no array serÃ£o avaliados.


>>>>> Para fixar ainda mais o conceito de reduce, faÃ§a uma funÃ§Ã£o que some todos os nÃºmeros pares do array numbers.
(NO VSC: evenValue.js)

>>>>> Agora, crie uma funÃ§Ã£o usando dados de estudantes, para mostrar na tela um relatÃ³rio que diz em qual matÃ©ria a pessoa foi melhor. VocÃª usarÃ¡ tanto o map quanto o reduce dentro dele!
(NO VSC: studentData.js)