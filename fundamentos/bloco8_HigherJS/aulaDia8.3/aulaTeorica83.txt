INTRODU√á√ÉO
======================================

O QUE VAMOS APRENDER?
Sobre as Higher Order Functions:   >>>>>>> Array.filter e o Array.reduce. <<<<<<<

O filter e o reduce s√£o algumas das mais poderosas fun√ß√µes para MANIPULA√á√ÉO E CRIA√á√ÉO DE ARRAYS. Enquanto o filter filtra o array de acordo com alguma condi√ß√£o e retorna apenas os valores que satisfizerem a essa condi√ß√£o, o reduce consegue reduzir o array a um valor √∫nico.
======================================

SKILLS ESPERADAS
        - Utilizar a fun√ß√£o Array.filter para filtrar um array;

        - Utilizar a fun√ß√£o Array.reduce para manipular arrays e construir resultados diversos;

        - Aprender a usar de forma conjunta as Higher Order Functions.
======================================

IMPORT√ÇNCIA

Imagine que voc√™ possua um array de n√∫meros e strings e precise somente dos n√∫meros. Como voc√™ resolveria esse problema? ü§î

Voc√™ pode ter pensado em v√°rias solu√ß√µes, mas nessa situa√ß√£o voc√™ pode utilizar o >>> filter <<<, que, como o pr√≥prio nome diz, filtra os dados de um array. Dessa maneira, voc√™ consegue filtrar somente os n√∫meros do array, usando apenas uma linha de c√≥digo.

E se voc√™ precisasse somar todos os n√∫meros desse novo array, como voc√™ faria?

Para realizar a soma de todos os n√∫meros do array, voc√™ pode utilizar o >>> reduce <<<, que vai passar por cada n√∫mero do seu array e reduzir esse array a um valor √∫nico.



========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================


Array.filter

O filter √© uma fun√ß√£o respons√°vel por realizar algum tipo de filtro no array, de acordo com uma condi√ß√£o.

Imagine que voc√™ tenha ficado respons√°vel por um sistema de cadastro de clientes de uma loja de roupas e precise apenas dos nomes. Ao salvar o cadastro, o nome e o n√∫mero do telefone foram salvos dentro de um mesmo array.

O c√≥digo abaixo mostra como ficou o resultado do array:


                  const dados = ['Luca', 91234567, 'Ana', 92345678, 'Marlete', 93456789];


√â nessa situa√ß√£o que o filter entra em a√ß√£o! A sintaxe dele √© a seguinte (mesma das outras HOFs):

                                array.filter(() => {});

O filter faz uma itera√ß√£o no array e recebe como par√¢metro uma callback.

                                array.filter((item) => {});

Dentro do escopo da fun√ß√£o √© onde inserimos a condi√ß√£o a ser filtrada.


>>>>> Para refletir üí≠: Voc√™ precisa filtrar apenas o nome das pessoas do seu array dados. Ele possui dois tipos de informa√ß√µes: o nome, que √© do tipo string, e o n√∫mero de telefone, que √© do tipo number. Pensando nisso, como voc√™ faria para pegar apenas os elementos do tipo string, que s√£o referentes ao nome das pessoas? ü§î <<<<<<


Se voc√™ pensou no filter, acertou! Voc√™ pode realizar a filtragem do array dados e na condi√ß√£o, verificar pelos elementos do tipo string.


                          const dados = ['Luca', 91234567, 'Ana', 92345678, 'Marlete', 93456789];

                          dados.filter((item) => {
                            // retorne apenas os elementos que s√£o do tipo string
                            return typeof item === 'string';
                          });
                          // ['Luca', 'Ana', 'Marlete']

Voc√™ pode fazer esse c√≥digo em apenas uma linha, omitindo a palavra return e retornando o valor logo ap√≥s a arrow =>:

                          const dados = ['Luca', 91234567, 'Ana', 92345678, 'Marlete', 93456789];

                          dados.filter((item) => typeof item === 'string');
                          // ['Luca', 'Ana', 'Marlete']


Agora vamos supor que voc√™ queira apenas os valores que n√£o s√£o strings do array dados. Como faria isso? Basta alterar a condi√ß√£o do nosso filter!

                          dados.filter((item) =>  typeof item !== 'string');    // n√£o seja string

A condi√ß√£o de dentro do filter √© para retornar sempre que o elemento for diferente de string.

-----------
Outro exemplo:
Imagine agora que voc√™ possua um array chamado listaNumeros com os valores 10, 20, 30, 40.

                          const listaNumeros = [10, 20, 30, 40];

Voc√™ precisa somente dos n√∫meros maiores que 20 do array listaNumeros. Como isso pode ser feito? Se voc√™ pensou em utilizar o m√©todo filter, acertou de novo! O array pode ser filtrado com a condi√ß√£o de o n√∫mero ser maior que 20. 


                          const listaNumeros = [10, 20, 30, 40];

        // Armazena o resultado em uma nova vari√°vel maiorVinte
                          let maiorVinte = listaNumeros.filter((item) => {
        // retorne apenas os elementos que s√£o maiores do que vinte
                            return item > 20;
                          });

                          console.log(maiorVinte);

----------------------
(v√≠deo - filter com array de objetos - Noel) - (algummmas infos aqui, outras no exScript.js)

ENTENDENDO O .filter() - exScript.js
Seleciona elementos de acordo com uma condi√ß√£o. √â chamado a partir do array (array.filter()). Assim como nas demais HOFs, s√≥ o primeiro par√¢metro √© obrigat√≥rio, que √© o que vai passar por todos os elementos do array. Os outros dois s√£o o index e o pr√≥prio array original, mas s√≥ s√£o usados em alguns casos, n√£o s√£o necess√°rios, em geral.
Funciona como o 'for' por tb iterar todos os elementos. 

O .filter() SEMPRE retorna um array, mesmo que seja um s√≥ elemento filtrado ou um array vazio.


========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================


Array.reduce

Imagine que voc√™ tenha ficado respons√°vel por criar uma p√°gina de carrinho de compras e para isso √© necess√°rio realizar a soma de todos os itens do carrinho para retornar o valor final da compra.

O pre√ßo dos itens do carrinho est√£o dentro de um array e, para resolver esse problema, voc√™ pode utilizar o reduce, que √© respons√°vel por passar por cada um dos valores, >>>>>>>>>>> reduzindo o array a um √∫nico valor, que nesse caso √© o valor total da compra. <<<<<<<<<<<<<

Mas como o reduce funciona? ü§î

Diferente das outras HOFs, o reduce recebe dois par√¢metros: o primeiro √© uma callback, e o segundo par√¢metro √© um valor inicial (que √© opcional).

                              array.reduce(callback, valorInicial);

O valorInicial √© o valor da primeira itera√ß√£o e, em geral, ao realizar somas, esse valor √© 0.

J√° a callback √© a fun√ß√£o que vai passar por cada um dos itens do array, e ela pode receber at√© 4 par√¢metros, sendo eles:

     - Acumulador: que √© o valor que vai ser acumulado a cada itera√ß√£o;
     - Valor atual: que √© o valor atual do item, a ser adicionado no acumulador;
     - Index atual: que √© o index do item que est√° sendo iterado naquele momento;
     - Array: que √© o array original.

            array.reduce((acumulador, valorAtual, indexAtual, array) => { "c√≥digo" }, valorInicial);
                                  array.reduce(() => {}, in√≠cio);

>>>> Dos 4 par√¢metros que a callback pode receber, apenas dois s√£o obrigat√≥rios: o ACUMULADOR e o VALOR ATUAL. <<<

==========================================================================================================
OU SEJA, no reduce √© obriigat√≥rio ter a callback e na callback √© obrigat√≥rio ter acumulador e valor atual.
==========================================================================================================

Os par√¢metros acumulador e valor atual em geral s√£o escritos em ingl√™s e abreviados. Sendo assim:

          o acumulador √© chamado de acc (accumulator);
          o valor atual √© chamado de curr (current value).

Temos ent√£o que acc, abreviatura de accumulator, ou acumulador, deve obrigatoriamente ser o primeiro par√¢metro da callback, e o curr, abreviatura de currentValue, ou valor atual, tamb√©m obrigat√≥rio, deve ser o segundo par√¢metro da callback. Sendo assim, para trabalhar com a fun√ß√£o reduce voc√™ deve ter algo parecido com o c√≥digo abaixo:


                                  array.reduce((acc, curr) => {
                                    // escopo de execu√ß√£o da fun√ß√£o
                                  }, valorInicial);


A fun√ß√£o do acumulador (acc) √© guardar o retorno da callback a cada itera√ß√£o, e a fun√ß√£o do curr √© acessar cada um dos valores do array.



==========================================================================================================
(AULA AO VIVO COM O THALLES - V√çDEO - NOTAS)
A fun√ß√£o '.reduce()' reduz o array a um √∫nico valor (pode ser uma string, um n√∫mero, um array, um objeto).

EXEMPLO NA VIDA REAL:
5 amigos v√£o pagar uma conta de 50 reais num bar, sendo que cada um pediu um drink de 10 reais. Ou seja, 10 reais de cada. Esse, em reduce, seria o valor do acumulador === 10.

- A primeira pessoa tem 10 reais e passa para a segunda, que agora tem os 10 reais passados e mais os seus pr√≥prios 10 reais, o que faz 20. Esse √© o novo acumulador === 20, ou seja, o valor acumulado naquele dado momento.
- Essa segunda pessoa passa os 20 reais para a pr√≥xima, sendo que √© 10 + 10, e agora essa nova pessoa vai ter 30, incluindo seus pr√≥prios 10 reais. Sendo assim, o novo acumulador √© 30.
- Isso vai acontecer at√© chegarmos √† √∫ltima pessoa, que vai acrescentar seus pr√≥prios 10 reais e atingir o valor de 50 reais, que √© o total da conta e o acumulador final.


.reduce(callbackfn, valor inicial);   // valor inicial √© opcional e, se estabelecido, vai ser o 1¬∫ valor do accumulator
        ==========
            ‚è¨
A callbackfn √© obrigat√≥ria e recebe como par√¢metros obrigat√≥rios (accumulator, currentValue).
                                                                 ===========================

(accumulator, currentValue) => {}      // pode receber index e o array tb, opcionalmente


Se no fim, o array de retorno for vazio, ele vai possuir o valor inicial como elemento. Embora opcional, √© importante analisar quando ele √© necess√°rio para que a fun√ß√£o e o accumulator possam funcionar de forma correta, de acordo com o que se quer executar. Ele ajuda com a l√≥gica, sem ele podemos chegar em 'undefined', etc.

(PR√ÅTICA COM O THALLES - VSC)


==========================================================================================================



--------------------------
O c√≥digo abaixo possui um array simulando o valor dos itens no carrinho de compras e a fun√ß√£o do reduce para mostrar o que cada um dos par√¢metros retorna. Execute o c√≥digo abaixo no console do seu navegador e veja o que ele retorna:


                                  const valorItens = [1, 32, 44, 2, 3];

                                  valorItens.reduce((acc, curr) => {
                                    console.log(`acumulador - acc:`, acc);
                                    console.log(`valorAtual - curr:`, curr);
                                  }, 0);

Veja que, na primeira itera√ß√£o, o valor do acc √© 0, e depois se torna undefined.

Isso ocorre porque a fun√ß√£o do acumulador (acc) √© guardar o retorno da callback a cada itera√ß√£o, tendo como ponto de partida o valorInicial, que definimos como 0. Como a callback n√£o est√° retornando nada, o valor se torna undefined, porque ele n√£o acumulou nenhum resultado.
--------------------------

Para realizar a soma dos produtos, precisamos retornar esse c√°lculo dentro da callback.

                                  valorItens.reduce((acc, curr) => {
                                    console.log(`acc:`, acc);
                                    console.log(`curr:`, curr);
                                    console.log('a soma atual √©', acc + curr);

                                    return acc + curr;
                                  }, 0);

Veja que, a cada itera√ß√£o, o acc e o curr s√£o somados, e o acc √© o valor acumulado da soma na itera√ß√£o anterior.

Ao final de toda a itera√ß√£o √© retornado o valor da soma de todos os itens do array e, nesse caso, voc√™ j√° sabe o valor total da compra.

Abaixo voc√™ pode conferir o c√≥digo comentado com o passo a passo do que acontece:

                                  -----------------------

                                  const valorItens = [1, 32, 44, 2, 3];

                                  valorItens.reduce((acc, curr) => {
                                    console.log(`valor atual √© ${curr}`);

                              >>>> // Antes da primeira itera√ß√£o o valor de in√≠cio do `acc` √© o valor no index 0 do array, e o valor de in√≠cio de `curr` √© o valor no index 1 do array. <<<<
                                    // Itera√ß√£o 1: valor do acc √© 1 e o de curr √© 32;
                                    // Ap√≥s a primeira itera√ß√£o, o valor de `acc` muda e passa a acumular agora o resultado do retorno da callback (acc + curr).
                                    // Itera√ß√£o 2: valor do acc √© 33 e o de curr √© 44;
                                    // Acontece ent√£o uma segunda itera√ß√£o, e `curr` agora assume o valor do index na sequ√™ncia do array, no caso o valor do segundo index e `acc` segue armazenando os retornos.
                                    // Itera√ß√£o 3: valor do acc √© 77 e o de curr √© 2;
                                    // Itera√ß√£o 4: valor do acc √© 79 e o de curr √© 3;
                                    // Valor final de `acc` √© 82 e `curr` para no 3.

                                    return acc + curr; 
                                    
                                    // Ao fim das itera√ß√µes podemos ver que o `acc` armazenou o resultado total do retorno da fun√ß√£o.
                                  });


                                    console.log(`valor atual √© ${curr}`);
                                    // Antes da primeira itera√ß√£o o valor de in√≠cio do `acc` √© o valor no index 0 do array, e o valor de in√≠cio de `curr` √© o valor no index 1 do array.
                                    // Itera√ß√£o 1: valor do acc √© 1 e o de curr √© 32;
                                    // Ap√≥s a primeira itera√ß√£o, o valor de `acc` muda e passa a acumular agora o resultado do retorno da callback (acc + curr).
                                    // Itera√ß√£o 2: valor do acc √© 33 e o de curr √© 44;
                                    // Acontece ent√£o uma segunda itera√ß√£o, e `curr` agora assume o valor do index na sequ√™ncia do array, no caso o valor do segundo index e `acc` segue armazenando os retornos.
                                    // Itera√ß√£o 3: valor do acc √© 77 e o de curr √© 2;
                                    // Itera√ß√£o 4: valor do acc √© 79 e o de curr √© 3;
                                    // Valor final de `acc` √© 82 e `curr` para no 3.

                                    return acc + curr; // Ao fim das itera√ß√µes podemos ver que o `acc` armazenou o resultado total do retorno da fun√ß√£o.
                                  });

                                  ----------------------------------
Ao observar o c√≥digo acima, identificamos tamb√©m o papel do curr, que sempre armazena o valor do elemento atual, ou seja, o elemento do array que est√° sendo iterado no momento.


===============================================================

Passando um valor para o acc:
Imagine que novamente voc√™ queira somar todos os valores de um array. Mas agora teremos um valor inicial j√° estipulado para o acc.

                                  Com o antigo 'for':

                                  const numbers = [1, 32, 44, 2, 3];
                                  let sumNumbers = 30;

                                  // A vari√°vel `sumNumbers` tem um valor inicial de 30 e vai acumulando, a cada itera√ß√£o do for, o resultado da opera√ß√£o feita em seu escopo!

                                  for (let index = 0; index < numbers.length; index += 1) {
                                    sumNumbers += numbers[index];
                                  }

                                  console.log(sumNumbers); 
                                  // 112


                                  -----------------------
                                  Com o 'reduce':

                                  const numbers = [1, 32, 44, 2, 3];

                                  const totalSum = numbers.reduce((acc, curr) => {
                                    console.log(`valor do acc √© ${acc} e o de curr √© ${curr}`);

                                    // Itera√ß√£o 1: valor do acc √© 30 e o de curr √© 1
                                    // Itera√ß√£o 2:valor do acc √© 31 e o de curr √© 32
                                    // Itera√ß√£o 3: valor do acc √© 63 e o de curr √© 44
                                    // Itera√ß√£o 4: valor do acc √© 107 e o de curr √© 2
                                    // Itera√ß√£o 5: valor do acc √© 109 e o de curr √© 3
                                    // Valor final de `acc`√© 112 e `curr` para no 3


                                    return acc + curr;
                                  }, 30); 
                                  // O `valorInicial` √© 30, ou seja, `acc` antes de executar a primeira itera√ß√£o j√° est√° armazenando esse valor.

                                  console.log(`valor final do acc √© ${totalSum}`);
                                  // por fim, esse `console.log` imprime o retorno da nossa fun√ß√£o, que √© o valor final de `acc` ap√≥s cada uma das 5 itera√ß√µes, tendo iniciado com valor 30.


Pode parecer estranho definir um valor fixo para o acumulador, mas isso acontece porque estamos trabalhando com n√∫meros. O reduce √© uma ferramenta poderosa e, em um c√≥digo mais complexo, ele poderia receber um valor din√¢mico, atrav√©s de uma vari√°vel, ou at√© mesmo qualquer valor que n√£o seja um n√∫mero. Vale lembrar tamb√©m que voc√™ aprendeu a usar o reduce com seus dois primeiros par√¢metros, mas, embora pouco utilizados, existem mais dois par√¢metros opcionais: index e array.


-----------------------------------------------------------------------
Veja tamb√©m que, ao inv√©s de passar a l√≥gica direto dentro da callback do reduce, voc√™ pode criar uma fun√ß√£o externa e cham√°-la como sendo o par√¢metro callback:

                              const numbers = [1, 32, 44, 2, 3];

                              const sumNumbers =  (acc, curr) => acc + curr;    // callback

                              const totalSum = numbers.reduce(sumNumbers, 30);

                              console.log(totalSum); //112
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------

OUTROS EXEMPLOS DE USO DO REDUCE:

>>>>> Hora de olhar outro exemplo para fixar e mostrar outras formas de se usar o reduce. Neste exemplo, ser√£o comparados valores para buscar o maior valor em um array.
(NO VSC: maiorValor.js)

Pronto! Voc√™ encontrou o maior n√∫mero do array utilizando reduce ü•≥

Geralmente, para encontrar o maior valor de um array utilizando o reduce, n√£o utilizamos um valor inicial. Dessa forma, apenas valores presentes no array ser√£o avaliados.


>>>>> Para fixar ainda mais o conceito de reduce, fa√ßa uma fun√ß√£o que some todos os n√∫meros pares do array numbers.
(NO VSC: evenValue.js)

>>>>> Agora, crie uma fun√ß√£o usando dados de estudantes, para mostrar na tela um relat√≥rio que diz em qual mat√©ria a pessoa foi melhor. Voc√™ usar√° tanto o map quanto o reduce dentro dele!
(NO VSC: studentData.js)